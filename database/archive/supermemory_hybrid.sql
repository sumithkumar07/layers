-- 1. Enable Extensions
create extension if not exists vector;

-- 2. Create the Hybrid Memory Table
create table memories (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  content text not null,
  
  -- Semantic Search (Vector)
  embedding vector(384) not null,
  
  -- Keyword Search (Full Text Search)
  content_tsvector tsvector generated always as (to_tsvector('english', content)) stored,
  
  -- Graph / Metadata (Tags)
  tags text[],
  
  created_at timestamp with time zone default now()
);

-- 3. Create Indexes for Speed
-- Vector Index (IVFFlat is good for speed/recall balance)
create index on memories using ivfflat (embedding vector_cosine_ops)
with (lists = 100);

-- User ID Index (for RLS queries filtering by user_id)
create index on memories (user_id);

-- Keyword Index (GIN is standard for text search)
create index on memories using gin (content_tsvector);

-- Tags Index
create index on memories using gin (tags);

-- 4. Enable Security (RLS)
alter table memories enable row level security;

-- Policy: Users can only see their own memories
create policy "Users view their own memories"
on memories for select
using ( auth.uid() = user_id );

-- Policy: Users can only insert their own memories
create policy "Users insert their own memories"
on memories for insert
with check ( auth.uid() = user_id );

-- Policy: Users can only update their own memories
create policy "Users update their own memories"
on memories for update
using ( auth.uid() = user_id );

-- Policy: Users can only delete their own memories
create policy "Users delete their own memories"
on memories for delete
using ( auth.uid() = user_id );

-- 5. Hybrid Search Function
-- This function combines Vector Similarity with Keyword Matching
create or replace function match_memories_hybrid (
  query_embedding vector(384),
  query_text text,
  match_threshold float,
  match_count int
)
returns table (
  id bigint,
  content text,
  similarity float,
  rank float
)
language sql stable
as $$
  select
    memories.id,
    memories.content,
    1 - (memories.embedding <=> query_embedding) as similarity,
    ts_rank(memories.content_tsvector, plainto_tsquery('english', query_text)) as rank
  from memories
  where 1 - (memories.embedding <=> query_embedding) > match_threshold
  or ts_rank(memories.content_tsvector, plainto_tsquery('english', query_text)) > 0
  order by similarity desc, rank desc
  limit match_count;
$$;
