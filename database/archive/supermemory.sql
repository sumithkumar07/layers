-- 1. Enable Vector Support (The Memory Brain)
create extension if not exists vector;

-- 2. Create the Memory Table
create table memories (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null, -- Links memory to specific user
  content text not null,                      -- The text to remember
  embedding vector(384) not null,              -- The math version of the text
  created_at timestamp with time zone default now()
);

-- Index for RLS queries filtering by user_id
create index on memories (user_id);

-- Vector index for similarity search (IVFFlat for moderate datasets)
create index on memories using ivfflat (embedding vector_cosine_ops)
with (lists = 100);

-- 3. Enable Security (RLS) - CRITICAL FOR PRIVACY
alter table memories enable row level security;

-- 4. Create the Policy (The Force Field)
-- "Users can only see their own memories"
create policy "Users view their own memories"
on memories for select
using ( auth.uid() = user_id );

-- "Users can only insert their own memories"
create policy "Users insert their own memories"
on memories for insert
with check ( auth.uid() = user_id );

-- 5. Create a Search Function (For RAG)
create or replace function match_memories (
  query_embedding vector(384),
  match_threshold float,
  match_count int
)
returns table (
  id bigint,
  content text,
  similarity float
)
language sql stable
as $$
  select
    memories.id,
    memories.content,
    1 - (memories.embedding <=> query_embedding) as similarity
  from memories
  where 1 - (memories.embedding <=> query_embedding) > match_threshold
  order by memories.embedding <=> query_embedding
  limit match_count;
$$;
